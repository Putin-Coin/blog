<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Decoupling Your HTML, CSS, and JavaScript &mdash; Philip Walton</title>

    <!-- http://t.co/dKP3o1e -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name=viewport content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">
    <link href="http://philipwalton.com/assets/stylesheets/application.css" rel="stylesheet" type="text/css">
    <link href="http://feeds.feedburner.com/philipwalton" rel="alternate" title="" type="application/atom+xml">
    
      <link rel="canonical" href="http://philipwalton.com/articles/decoupling-html-css-and-javascript/">
    
    <meta name="description" content="Thoughts on front-end development, architecture, and the future of the web.">
    <!--[if lt IE 9]>
    <script src="http://philipwalton.com/assets/javascripts/html5shiv.js"></script>
    <script src="http://philipwalton.com/assets/javascripts/respond.js"></script>
    <![endif]-->
  </head>
  <body>
    <header class="header" role="banner">
      <div class="l-container">
        <div class="l-header-main">
  <h1 class="header__title"><a href="http://philipwalton.com/" rel="home">Philip Walton</a></h1>
  <h2 class="header__description">On Front End Web Development</h2>
</div>
        
    


<nav class="l-header-nav" role="navigation">
  <ul class="nav">
    <li><a  href="http://philipwalton.com/">Home</a></li>
    <li><a class="is-selected" href="http://philipwalton.com/articles/">Articles</a></li>
    <li><a  href="http://philipwalton.com/about/">About</a></li>
  </ul>
</nav>
      </div>
    </header>
    <div class="l-container">
      <section class="l-content" role="main">
        
<article role="article">

  <header class="page-header">
  <h1 class="page-header__title">
    
      Decoupling Your HTML, CSS, and JavaScript
    
  </h1>
  
    <ul class="article-meta">
  <li>
    
    
      <time datetime="2013-08-17">August 17, 2013</time>
    
  </li>
  <li>Tagged as:
  
  
    
    <a href="http://philipwalton.com/tags/css/">CSS</a>,
  
    
    <a href="http://philipwalton.com/tags/html/">HTML</a>,
  
    
    <a href="http://philipwalton.com/tags/javascript/">JavaScript</a>
  
  </li>
</ul>
  
</header>

  <p>Any non-trivial site or application on the Web today will contain a large amount of HTML, CSS, and JavaScript. As the use of the Internet evolves and our dependence on it increases, having a plan for organizing and maintaining your front-end code is an absolute must.</p>

<p>In today's large Web companies, an increasing number of people are touching an increasingly large percentage of the front-end code. As a result, most organizations struggle to keep their code modular. Changes to one part of the application often inadvertently break unrelated parts downstream.</p>

<p>Preventing unintended consequences is not an easy problem to solve, especially since HTML, CSS, and JavaScript are, by their nature, co-dependent.</p>

<p>To make matters worse, traditional computer science principles like the separation of concerns, which have long been a part of server-side development, rarely get discussed when it comes to front-end code.</p>

<p>In this article I'll talk about how I've learned to decouple my HTML, CSS, and JavaScript. From my experience and the experience of people I know, the best ways to accomplish this are far from obvious, often counter-intuitive, and sometimes go against much of the so-called "best-practices" out there.</p>

<h2>The Goal</h2>

<p>There will always be some coupling between HTML, CSS, and JavaScript. For better or for worse, these technologies were built to interact with each other. As an example, a fly-in transition might be defined with a class selector in a stylesheet, but it is often triggered by user interaction, applied via JavaScript, and initiated by adding the class to the HTML.</p>

<p>Since some coupling in your front-end code is inevitable. Your goal shouldn't be to simply eliminate coupling altogether. It should be to minimize the coupling that makes certain code parts unnecessarily dependent on others.</p>

<p>A back-end developer should be able to change the markup in an HTML template without worrying about accidentally breaking a CSS rule or some JavaScript functionality. As today's Web teams grow in size and specialization, this goal is more important than ever.</p>

<h2>Anti-Patterns</h2>

<p>It's not always obvious when front-end code is tightly coupled. And this is compounded by the fact that what may seem like loose coupling from one perspective is actually tight coupling from another.</p>

<p>The following are all anti-patterns I've either seen repeatedly or done myself and learned from my mistakes. In each, I try to explain why the coupling is bad and how it can be avoided.</p>

<h3>Overly Complex Selectors</h3>

<p>CSS Zen Garden showed the world that you can completely change the look of an entire website without changing the markup at all. It was the poster child of the semantic Web movement, and one of its main tenets was to avoid the use of presentational classes.</p>

<p>At first glance, CSS Zen Garden may seem like a great example of decoupling. After all, its entire point was to separate the style from the markup. The problem, however, is that to do this you usually need selectors in your stylesheet that look like this:</p>

<pre class="highlight"><code class="language-css">#sidebar section:first-child h3 + p { }</code></pre>


<p>In CSS Zen Garden, the HTML is almost entirely decoupled from the CSS, but the CSS is extremely coupled to the HTML and requires an intimate knowledge of its markup structure.</p>

<p>This may not seem bad if the person maintaining the CSS also maintains the HTML, but as soon as you add a few more people to the mix, it can quickly get out of hand. If a developer comes along and adds a <code>&lt;div&gt;</code> before the first <code>&lt;section&gt;</code>, the above rule won't work, and the developer may not even know.</p>

<p>CSS Zen Garden is a great idea as long as the markup of your site is rarely changing. But that's usually not the case with today's Web apps.</p>

<p>Instead of long, complex CSS selectors, it's best to (whenever possible) style all your visual components with one or more classes on the root element of the component itself. For example, if you have submenus in your sidebar, just add the class <code>submenu</code> to each of the submenu elements. Don't use a rule like:</p>

<pre class="highlight"><code class="language-css">ul.sidebar &gt; li &gt; ul {
  /* submenu styles */
}</code></pre>


<p>This approach ends up requiring more classes in the HTML, but it lowers the coupling between it and this CSS making the code much more reusable and maintainable in the long run. It also makes your markup self-documenting. If there are no classes in the HTML, a developer who is unfamiliar with the CSS has no idea how her markup changes will affect other code. On the other hand, if there are classes in the HTML it is very obvious what styles or functionality is being applied.</p>

<h3>Classes With More Than One Responsibility</h3>

<p>Sometimes a class is used for both styling purposes and as a JavaScript hook. While this may seem like a savings (since it requires one fewer class in the markup) it actually couples the presentation of the element to its functionality.</p>

<pre class="highlight"><code class="language-xml">&lt;button class=&quot;add-item&quot;&gt;Add to Cart&lt;/button&gt;</code></pre>


<p>The above example shows an "Add to Cart" button styled with the <code>add-item</code> class.</p>

<p>If a developer wants to add a click event listener to this element, it can be quite tempting to hook into the class that's already there. I mean, if one already exists, why add another?</p>

<p>But imagine that there are many of these buttons throughout the site that all look the same and all invoke the same JavaScript functionality. Then imagine the marketing team wants a particular one of these buttons to look totally different than the rest of them. Maybe it needs to be a lot bigger with a more eye-catching color.</p>

<p>This is a problem because the JavaScript code that is listening for the click event is expecting the class <code>add-item</code> to be used, but your new button now cannot use that class (or it must unset everything it declared and reset the new styles). It's even more of a problem if you have some testing code that is also expecting the <code>add-item</code> class to be present, so you'll have yet another place where code needs to be updated.</p>

<p>Worse still is if your "Add to Cart" functionality is used by more than just this application. If the code has been abstracted to a separate module then what should have been a simple style change can now potentially introduce bugs in a completely different application.</p>

<p>It's perfectly acceptable (actually encouraged) to use classes as JavaScript hooks, but if you're going to do so, do it in a way that avoids coupling between style classes and behavior classes.</p>

<p>My personal recommendation is to use a prefix for all JavaScript hooks. I use <code>js-*</code>. That way, when a developer sees such a class in the HTML source, she'll know exactly where to look to discover its purpose.</p>

<p>The "Add to Cart" example above would then be rewritten as:</p>

<pre class="highlight"><code class="language-xml">&lt;button class=&quot;js-add-to-cart add-item&quot;&gt;Add to Cart&lt;/button&gt;</code></pre>


<p>Now if one particular "Add to Cart" button needs to look different, you can simply change the style class and leave the behavior class alone.</p>

<pre class="highlight"><code class="language-xml">&lt;button class=&quot;js-add-to-cart add-item-special&quot;&gt;Add to Cart&lt;/button&gt;</code></pre>


<h3>JavaScript That Knows Too Much About Styling</h3>

<p>In the same way that JavaScript can use classes to find elements in the DOM, it can also add or remove classes to change the style of elements. But this can be a problem if those classes aren't identifiably different from the classes that appear on page load.</p>

<p>When JavaScript code knows too much about component styling it becomes very easy for a CSS developer to make changes to a stylesheet and not realize he's breaking critical functionality.</p>

<p>This is not to say that JavaScript shouldn't alter the look of visual components after the user interacts with them, but if it does it should do so through an agreed-upon interface. It should use classes that are identifiably different from the classes that define the default styling.</p>

<p>Similar to <code>js-*</code> prefixed classes, I recommend using the prefix <code>is-*</code> to define class selectors that alter the state of a visual component. An example CSS rule might look like this:</p>

<pre class="highlight"><code class="language-css">.pop-up.is-visible { }</code></pre>


<p>Notice that the state class (<code>is-visible</code>) is chained to the component class (<code>pop-up</code>); this is important. Since state rules describe the state of a component, they should not appear on their own. This distinction helps further differentiate state styling from default component styling.</p>

<p>In addition, by using a prefix like <code>is-*</code> we can write tests to ensure that this convention is followed. One way to test these types of rules is using <a href="http://csslint.net">CSSLint</a> and <a href="http://philipwalton.com/articles/introducing-html-inspector/">HTML Inspector</a>.</p>

<p>More information about state specific classes can be found in the excellent <a href="http://smacss.com/">SMACSS</a> book by <a href="http://snook.ca/">Jonathan Snook</a>.</p>

<h3>JavaScript "Selectors"</h3>

<p>jQuery and newer APIs like <code>document.querySelectorAll</code> make it extremely easy for users to find elements in the DOM via a language they're already familiar with &mdash; CSS selectors. While this is very powerful, it comes with the same problem that CSS selectors already have.</p>

<p>JavaScript “selectors" should not rely too heavily on the DOM structure. Such selectors are significantly slower and require far too intimate a knowledge of the HTML.</p>

<p>As with the first example, a developer working on an HTML template should be able to make basic changes to the markup without fear of it breaking essential functionality. If there is functionality that can be broken, it should be apparent in the markup.</p>

<p>I've already mentioned that <code>js-*</code> prefixed classes should be used as JavaScript hooks. In addition to disambiguating styling classes from functional classes, they also express intention in the markup. When someone editing the HTML sees a <code>js-*</code> prefixed class, they'll know it's used for something. If the JavaScript code is instead depending on a particular markup structure to query for elements, it won't be apparent in the markup that anything functional is happening.</p>

<p>Instead of traversing the DOM with long, complex selectors, stick to single class selectors or IDs.</p>

<p>Consider the following code:</p>

<pre class="highlight"><code class="language-javascript">var saveBtn = document.querySelector(&quot;#modal div:last-child &gt; button:last-child&quot;)</code></pre>


<p>This long selector saves you from having to add a class to the HTML, but it also makes your code very susceptible to markup changes. If the designers suddenly decide to put the save button on the left and the cancel button on the right, the selector will no longer match.</p>

<p>A much better approach (using the prefix method mentioned above) would be to just use a class.</p>

<pre class="highlight"><code class="language-javascript">var saveBtn = document.querySelector(&quot;.js-save-btn&quot;)</code></pre>


<p>Now the markup can change all it wants, and as long as the class is still on the correct element, everything will work just fine.</p>

<h2>Classes Are Your Contract</h2>

<p>Almost every type of coupling between HTML, CSS, and JavaScript can be lessened with an appropriate use of classes and a predictable class naming convention.</p>

<p>At first glance it may seem like using a lot of classes in the markup is a sign of tight coupling, since the HTML needs to know the names of those classes in order to work. But I see the use of classes as very similar to the event or observable pattern in traditional program design.</p>

<p>In event driven programming, instead of object A calling a method on object B, it simply emits a particular event in a given circumstance, and object B can subscribe to that event. This way, object B doesn't need to know anything about object A's interface, it simply needs to know what event to listen for.</p>

<p>Arguably event systems require a form of coupling since Object B needs to know the names of the events to subscribe to, but it's quite a bit looser coupling than if Object A needed to know Object B's public methods.</p>

<p>HTML classes are very similar. Instead of a CSS file defining complex selectors (which, continuing the analogy, is equivalent to knowing the HTML's internal interface), it can simply define the look of a visual component via a single class. The HTML may then choose to use that class or not use it. The CSS doesn't need to care.</p>

<p>In the same way, JavaScript doesn't need complex DOM traversal functions that also require an intimate knowledge of the HTML structure, it can simply listen for the user's interaction with elements that contain the agreed-upon class names.</p>

<p>Classes should be the glue that connects your HTML, CSS, and JavaScript together. In my experience they're are the easiest and best way to connect the three technologies without intermingling them too much.</p>

<h2>The Future</h2>

<p>The <a href="http://www.whatwg.org/">WHATWG</a> is currently working on the <a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/">Web Components</a> specification, which will allow developers to bundle HTML, CSS, and JavaScript together as individual components or modules that are encapsulated from the rest of the page.</p>

<p>When that spec if implemented in the majority of browsers, a lot of the suggestions I've given in this article will become less critical (since it will be more obvious what code is meant to work with what); however, it's still important to understand these broader principles and why they're needed.</p>

<p>Even if these practices become less important in the era of Web Components, the theory still applies. Practices that work for large teams and big applications will still work for small modules written by individual developers. The reverse is not necessarily the case.</p>

<h2>Conclusion</h2>

<p>The mark of maintainable HTML, CSS, and JavaScript is when individual developers can easily and confidently edit parts of the code base without those changes inadvertently affecting other, unrelated parts.</p>

<p>One of the best ways to prevent unintended consequences is to connect these three technologies together through a predictable set of thoughtfully named classes that express their intention and reflect their chosen purpose to any developer who encounters them.</p>

<p>To avoid the above anti-patterns, keep the following principles in mind:</p>

<ul>
<li>Favor explicit component and behavior classes over complex CSS selectors in both CSS and JavaScript.</li>
<li>Style components based on what they are, not where they are.</li>
<li>Don't use the same class for both style and behavior.</li>
<li>Differentiate state styles from default styles.</li>
</ul>


<p>Using classes this way will often require a lot of classes being present in the HTML, but the gains in predictability and maintainability are well worth it. After all, adding classes to HTML is quite easy and something that a developer of any skill level can do. To quote <a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">Nicolas Gallagher</a>:</p>

<blockquote><p>When you choose to author HTML and CSS in a way that seeks to reduce the amount of time you spend writing and editing CSS, it involves accepting that you must instead spend more time changing HTML classes on elements if you want to change their styles. This turns out to be fairly practical, both for front-end and back-end developers &mdash; anyone can rearrange pre-built "lego blocks"; it turns out that no one can perform CSS-alchemy.</p></blockquote>


  
  
  <p class="callout callout--twitter">If you liked this article and think others should read it, please <a href="http://twitter.com/intent/tweet?text=Decoupling%20Your%20HTML%2C%20CSS%2C%20and%20JavaScript&url=http%3A%2F%2Fphilipwalton.com%2Farticles%2Fdecoupling-html-css-and-javascript%2F&via=philwalton">share it on Twitter</a>.
  </p>

  
    <div id="disqus_thread" class="l-comments"></div>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  

</article>
      </section>
      <aside class="l-widgets" role="complementary">

  <div class="widget">

    <p>Hello, I'm <strong>Philip Walton</strong>. I work as a senior front-end software engineer for <a href="http://appfolio.com/about">Appfolio</a> in Santa Barbara, CA. I'm passionate about open source software and the future of the Web. This blog is where I write about what I learn.</p>

    <a href="https://twitter.com/philwalton" class="twitter-follow-button" data-show-count="false" data-lang="en">Follow Me</a>

  </div>

  <div class="widget">
    <h3 class="widget__title">Popular Articles</h3>
    <ul>
      <li>
        <a href="http://philipwalton.com/articles/what-no-one-told-you-about-z-index/">What No One Told You About Z-Index</a>
      </li>
      <li>
        <a href="http://philipwalton.com/articles/decoupling-html-css-and-javascript/">Decoupling Your HTML, CSS, and JavaScript</a>
      </li>
      <li>
        <a href="http://philipwalton.com/articles/introducing-html-inspector/">Introducing HTML Inspector</a>
      </li>
      <li>
        <a href="http://philipwalton.com/articles/css-architecture/">CSS Architecture</a>
      </li>
    </ul>
  </div>

  <div class="widget">
    <h3 class="widget__title">Topics</h3>
    <ul>
    
    
      <li>
        
        <a href="http://philipwalton.com/tags/architecture/">Architecture</a>
        (3)
      </li>
    
      <li>
        
        <a href="http://philipwalton.com/tags/css/">CSS</a>
        (7)
      </li>
    
      <li>
        
        <a href="http://philipwalton.com/tags/html/">HTML</a>
        (4)
      </li>
    
      <li>
        
        <a href="http://philipwalton.com/tags/javascript/">JavaScript</a>
        (5)
      </li>
    
      <li>
        
        <a href="http://philipwalton.com/tags/oocss/">OOCSS</a>
        (3)
      </li>
    
      <li>
        
        <a href="http://philipwalton.com/tags/sass/">Sass</a>
        (2)
      </li>
    
    </ul>
  </div>

</aside>
      <footer class="l-footer" role="contentinfo">
  <p>
    &copy; 2013, <a href="http://twitter.com/philwalton">Philip Walton</a>. Built with <a href="https://github.com/mojombo/jekyll">Jekyll</a>
  </p>
</footer>
    </div>
    

  

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-21292978-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

      // track clicks on outbound hyperlinks
      (function() {

        var links = document.getElementsByTagName("a")
          , link
          , i = 0

        function isLink(el) {
          return el.nodeName.toLowerCase() == "a" && el.href
        }

        function isExternalLink(el) {
          return el.href.indexOf(location.host) < 0
        }

        function getLinkAncestor(el) {
          if (isLink(el)) return el
          while (el.parentNode && el.parentNode.nodeType == 1) {
            if (isLink(el)) return el
            el = el.parentNode
          }
        }

        function logExternalClicks(event) {
          var e = event || window.event
            , target = e.target || e.srcElement
            , link = getLinkAncestor(target)
          if (link && isExternalLink(link)) {
            _gaq.push(['_trackEvent', 'Outbound Link', link.href]);
          }
        }

        // add target="_blank" to external links
        while(link = links[i++]) {
          if (link.target != "_blank" && isExternalLink(link)) {
            link.target = "_blank"
          }
        }

        // register logging on click events
        if (document.addEventListener) {
          document.addEventListener("click", logExternalClicks)
        }
        else if (document.attachEvent) {
          document.attachEvent("onclick", logExternalClicks)
        }

      }())
    </script>

  


    
  <!--[if gte IE 9]><!-->
  <script src="http://philipwalton.com/assets/javascripts/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad()</script>
  <!--<![endif]-->

    <script>
  // Don't load the widgets when the sidebar isn't visible
  if (window.matchMedia && window.matchMedia("(min-width: 48em)").matches) {
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
  }
</script>

    
  <script>
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = "philipwalton"; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  </body>
</html>