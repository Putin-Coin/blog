
      

<article role="article" class="hentry">

  <header class="ContentHeader">
    <h1 class="ContentHeader-articleTitle entry-title">Do We Actually Need Specificity In CSS?</h1>
    <time class="ContentHeader-articleDate published"
        datetime="2015-11-01T14:37:42-08:00">
      November 1, 2015
    </time>
  </header>

  <div class="entry-content">
    
        <p>Okay, before I start, I want to get one thing out of the way upfront. This article is <em>not</em> a rant about how much I hate specificity. If you want to read an article like that, I’m sure you can find dozens elsewhere online.</p>
<p>What I want to do is pose an actual, honest question to the web development community and hopefully get people thinking.</p>
<p>To restate the question in a way that gets more at the heart of the issue: <em>If we lived in a world where specificity was never added to the cascade, would things be better or worse?</em></p>
<p>Now, I’m sure some people are thinking: <em>Who cares? Specificity exists, and we’re stuck with it. So what’s the point of bringing this up?</em></p>
<p>To anyone thinking that, I’m happy to inform you that you’re wrong :-)</p>
<p>In this article I’m going to show that it <em>is possible</em> to prevent specificity from affecting the cascade—meaning this question isn’t purely theoretical. If it turns out to be true that specificity does more harm than good, there’s something we can actually do about it today.</p>
<h2 id="a-little-background">A little background</h2>
<p>For anyone who’s a little rusty on how the cascade works, for normal CSS rules, the cascade takes three things into consideration: source order, specificity, and importance.</p>
<p>Source order makes a lot of sense. It’s natural and intuitive to think that if rule Y comes after rule X, and both rules apply to the same element, rule Y’s declarations should “win”.</p>
<p>Importance also makes a lot of sense. There are always going to be cases where you need to override something, and it’s good to have the option to do so. Importance is also the only way to override inline styles, so it’s actually quite necessary in some cases.</p>
<p>But I think specificity is different.</p>
<p>Specificity isn’t intuitive, and—especially for new developers—the results can often seem like a <em>gotcha</em> rather than the intended behavior. I’m also not sure there’s an equivalent in other systems or languages.</p>
<p>For example, what if specificity were a thing in JavaScript. Imagine how much more unpredictable your code would be if the following test passed.</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.document.foo = <span class="hljs-string">'bar'</span>;
<span class="hljs-built_in">document</span>.foo = <span class="hljs-string">'qux'</span>;

assert(<span class="hljs-built_in">window</span>.document.foo == <span class="hljs-string">'bar'</span>); <span class="hljs-comment">// true, WTF?</span>
</code></pre>
<p>It would be crazy and completely unmanageable if the <code>window.document.foo = 'bar'</code> assignment above (which comes first) trumped the <code>document.foo = 'qux'</code> assignment (which comes second) just because the reference was “more specific”. Yet that’s essentially what happens in CSS.</p>
<h2 id="but-specificity-is-useful-right">But specificity is useful, right?</h2>
<p>I’m sure there are thousands, probably even millions of websites out there that depend on specificity to make their styles work. If browsers started ignoring specificity tomorrow, all of those sites would break.</p>
<p>I’m not suggesting that specificity isn’t being used; clearly it is. What I <em>am</em> suggesting is that perhaps it’s not useful enough to make it worth the unpredictability and the confusion that comes with it.</p>
<p>I believe specificity is useful in the same way global variables can be useful. And just as most people consider reliance on global variables to be an anti-pattern, maybe it’s the same with specificity.</p>
<p>Moreover, I can’t think of a single time in my life when I’ve written a CSS rule that I wanted to override another CSS rule (using specificity) where I didn’t <em>also</em> put the more specific rule later in the source order.</p>
<p>To make that last statement more clear, I’ve never done something like in the example below, where the more-specific footer links are defined <em>before</em> the less-specific default links:</p>
<pre><code class="language-css"><span class="hljs-selector-class">.footer</span> <span class="hljs-selector-tag">a</span> {
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">text-decoration</span>: none;
}

<span class="hljs-selector-tag">a</span> {
  <span class="hljs-attribute">color</span>: blue;
  <span class="hljs-attribute">text-decoration</span>: underline;
}
</code></pre>
<p>If I want rule Y to override rule X, I put it later in the source order. Period. Which means any time I have a specificity conflict, it’s always an accident.</p>
<p>So that got me thinking, if I already expect rules later in the source order to always override rules earlier in the source order, what if I could make that happen regardless of the specificity of those rules?</p>
<p>Essentially, what if I could prevent myself (and other people on my team) from accidentally breaking away from the paradigm that we all agree makes the most sense.</p>
<h2 id="what-if-specificity-didnt-exist">What if specificity didn’t exist?</h2>
<p>Let’s imagine a world in which specificity doesn’t exist in CSS. In that world the cascade would be determined by source order and importance alone. So if rule X and Y both match a particular element, and rule Y comes after rule X in the source, rule Y will always win, regardless of the specificity of rule X. The only way for properties in rule X’s declaration to trump properties in rule Y’s declaration would be to use importance.</p>
<p>Would that be a better world? Would that lead to more predictable, maintainable, and scalable code?</p>
<h3 id="a-real-life-example">A real-life example</h3>
<p>Many people use “state” or “utility” classes in their CSS. An example of this is the class <code>is-hidden</code>, which (obviously) is used to hide an element.</p>
<p>Since state classes can be generically applied to any element, they’re usually defined as a single class selector, which makes their specificity pretty low. However, conceptually they’re an override-type class. By that I mean you wouldn’t add the class <code>is-hidden</code> to an element if you really wanted it to be visible.</p>
<p>If specificity didn’t exist, you could ensure state classes trumped other classes by simply including them last in the source order. But as it is today, you have to use <code>!important</code> to solve the problem.</p>
<p>For what it’s worth, adding <code>!important</code> in these situations is actually recommended when using <a href="https://smacss.com/book/type-state#tips">SMACSS state classes</a> and <a href="https://github.com/suitcss/utils-display/blob/0.4.2/lib/display.css">SUIT utility classes</a>. It would be nice if our best practices didn’t have to resort to the nuclear option for everyday styling needs.</p>
<h2 id="removing-specificity-from-the-cascade">Removing specificity from the cascade</h2>
<p>This is where things get pretty interesting. While it’s not possible to simply instruct the browser to ignore specificity altogether, it <em>is</em> possible to prevent specificity from affecting the cascade for a particular CSS file or set of CSS files.</p>
<p>How? The answer is to make specificity and source order the same.</p>
<p>Imagine a stylesheet in which all rules were ordered from least specific to most specific. In such a stylesheet, since the specificity of the rules also corresponds to the source order or the rules, specificity is effectively taken out of the equation.</p>
<p>Of course, most people don’t write their CSS this way, and expecting or asking them to do so would be unreasonable.</p>
<p>But what if a transpiler could modify your CSS, after you write it, to ensure all your selectors were in ascending-specificity order? And more importantly, what if it could do this without affecting what elements those selectors matched?</p>
<p>Thanks to some awesome quirks about how CSS selectors work, you can!</p>
<p>Consider the following CSS rules, currently in descending-specificity order (above each rule, I’ve listed the specificity using <code>[idCount].[classCount].[typeCount]</code> notation):</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0.2.5 */</span>
<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.content</span> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.1.3 */</span>
<span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.1.1 */</span>
<span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span> { }
</code></pre>
<p>These selectors can be rewritten to be in ascending-specificity order <em>without affecting the elements they’ll match</em>. I’ve highlighted the additions below:</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0.2.5 */</span>
<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.content</span> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.3.3 */</span>
<mark><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.4.1 */</span>
<mark><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span> { }
</code></pre>
<p>This works because all HTML documents have a root element (the <code>&lt;html&gt;</code> element), so adding the <code>:root</code> pseudo-class to the beginning of a selector won’t change what elements it can match.</p>
<p>And since pseudo-classes can be chained, i.e. <code>:root:root:root</code> will still match the <code>&lt;html&gt;</code> element, you can arbitrarily add specificity to any selector to make it more specific than the previous selector.</p>
<h3 id="handling-id-specificity">Handling ID specificity</h3>
<p>ID selectors are more specific than pseudo-class selectors, and therefore no amount of prepending <code>:root</code> to a selector will trump an ID.</p>
<p>However, the ID selector <code>#content</code> and the attribute selector <code>[id=&quot;content&quot;]</code> will match exactly the same element, so if you replace all ID selectors with attribute selectors, the technique described above will still work.</p>
<p>For example, the following rules:</p>
<pre><code class="language-css"><span class="hljs-comment">/* 1.1.5 */</span>
<span class="hljs-selector-tag">main</span><span class="hljs-selector-id">#content</span> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.1.3 */</span>
<span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.1.1 */</span>
<span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span> { }
</code></pre>
<p>Will get transpiled to:</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0.2.5 */</span>
<span class="hljs-selector-tag">main</span><mark><span class="hljs-selector-attr">[id="content"]</span></mark> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.3.3 */</span>
<mark><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-tag">aside</span><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span> { }

<span class="hljs-comment">/* 0.4.1 */</span>
<mark><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span> { }
</code></pre>
<h3 id="handling-selectors-that-may-already-refer-to-the-root-element">Handling selectors that may already refer to the root element</h3>
<p>With most selectors, it’s not possible to tell by looking at them whether they may be intending to match the <code>&lt;html&gt;</code> element. For example, if a site is using <a href="https://modernizr.com/">Modernizr</a>, you’ll probably see selectors that look like this:</p>
<pre><code class="language-css"><span class="hljs-selector-class">.columns</span> {
  <span class="hljs-attribute">display</span>: flex;
}

<span class="hljs-selector-class">.no-flexbox</span> <span class="hljs-selector-class">.columns</span> {
  <span class="hljs-attribute">display</span>: table;
}
</code></pre>
<p>To account for the possibility that either of these selectors might intend to match the <code>&lt;html&gt;</code> element, you’d have to include both possibilities and rewrite them as follows:</p>
<pre><code class="language-css"><mark><span class="hljs-selector-pseudo">:root</span></mark><span class="hljs-selector-class">.columns</span>,
<mark><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-class">.columns</span> {
  <span class="hljs-attribute">display</span>: flex;
}

<mark><span class="hljs-selector-pseudo">:root</span></mark><span class="hljs-selector-class">.no-flexbox</span> <span class="hljs-selector-class">.columns</span>,
<mark><span class="hljs-selector-pseudo">:root</span></mark> <span class="hljs-selector-class">.no-flexbox</span> <span class="hljs-selector-class">.columns</span> {
  <span class="hljs-attribute">display</span>: table;
}
</code></pre>
<p>Alternatively, you could avoid this problem entirely by establishing a convention that none of your selectors are allowed to match the <code>&lt;html&gt;</code> element, and that <code>&lt;body&gt;</code> is the highest they can go.</p>
<h3 id="the-full-rewriting-algorithm">The full rewriting algorithm</h3>
<p>I’m not aware of any transpiler that currently does what I’ve outlined in this article. If you were interested in trying to write one, I’d recommend doing so as a <a href="https://github.com/postcss/postcss">PostCSS</a> plugin. Since so many build steps already include <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> (which is a PostCSS plugin), adding this would have almost no impact on your build time or complexity.</p>
<p>Here’s the basic algorithm you’d need to follow:</p>
<ol>
<li>Iterate through each selector in your stylesheets.</li>
<li>For each selector:
<ol>
<li>If the selector contains any ID selectors, replace them with ID attribute selectors, otherwise do nothing.</li>
<li>Calculate the specificity of the current selector (with any IDs replaced).</li>
<li>If the current selector is the first selector, do nothing. Otherwise, compare its specificity to the specificity of the previous selector.</li>
<li>If the previous selector is less specific than the current selector, do nothing. Otherwise, rewrite the current selector so its specificity is greater than or equal to the specificity of the previous selector.
<ol>
<li>If the current selector begins with the <code>:root</code> selector or a type selector other than <code>html</code>, rewrite the selector with <code>:root</code> prepended as an ancestor. Otherwise rewrite the selector so the first part is listed both chained to <code>:root</code> and as a descendant of <code>:root</code>.</li>
</ol>
</li>
</ol>
</li>
<li>Once all selectors have been rewritten, output the final styles. They will now be in ascending-specificity order.</li>
</ol>
<h3 id="potential-downsides">Potential downsides</h3>
<p>While the approach I’ve outlined above can definitely work, it does come with a few downsides. For one thing, it will increase the file size of your CSS. This probably won’t be a big deal if you already keep your specificity low and write your rules in mostly ascending-specificity order. And, since it’s only adding the word “root” a bunch of times, it should gzip very well, so my guess is the difference will be negligible.</p>
<p>The other thing to be aware of is potential problems with referencing external styles. If you include <em>bootstrap.css</em> from a CDN and then use this technique on your other styles, there’s potential for weirdness since one set of selectors will be rewritten and the other set will not.</p>
<p>And you won’t necessarily be able to just include <em>bootstrap.css</em> in your build because it may or may not currently depend on specificity to work correctly.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>Before I conclude, I want to restate what I said in the intro. This is a question, not a prescription. I haven’t tried this technique in the wild, as I haven’t fully made up my mind about it.</p>
<p>I suspect it would vastly simplify things, but it also might uncover how much we truly depend on specificity.</p>
<p>If there’s a large team out there constantly fighting specificity battles, it would be interesting to hear if something like this helps. If you do try it, feel free to <a href="/about/#contact">let me know</a> your findings. Or better yet, write a follow-up article and I’ll link to it.</p>
<div class="Callout">
<p><strong>Update:</strong> <em>(November 3, 2015)</em></p>
<p><a href="https://twitter.com/LeaVerou">Lea Verou</a> pointed out to me <a href="https://twitter.com/LeaVerou/status/661617150243672064">on Twitter</a> that you could use the <code>:not()</code> pseudo-class as an alternative to using <code>:root</code> for arbitrarily increasing selector specificity.</p>
<p>The advantage of using <code>:not()</code> is you can apply it to any element (including <code>&lt;html&gt;</code>), so you wouldn’t have to split selectors. You could also use it to add type or ID-level specificity, e.g. <code>:not(z)</code> or <code>:not(#z)</code>, so you wouldn’t always have to increase by classes.</p>
<p>The downside of using <code>:not()</code> is you must be careful to pick a selector that’s guaranteed to not match the element, otherwise it won’t work.</p>
</div>
<div class="Callout">
<p><strong>Update:</strong> <em>(November 14, 2015)</em></p>
<p><a href="https://twitter.com/davidkpiano/">David Khourshid</a> wrote a response to this article entitled <a href="http://codepen.io/davidkpiano/post/the-simplicity-of-specificity">The Simplicity of Specificity</a> where he argues that CSS should not be compared to an imperative language, and things would be better if we wrote rules that were source order-independent. While it’s probably no surprise that I disagree with this position, I encourage you to read it if you want an alternative perspective.</p>
</div>

      
  </div>

  <footer class="entry-unrelated">
    <div id="share" class="Share">
      <span class="Share-figure">
        <svg viewBox="0 0 39 32">
          <use xlink:href="#icon-twitter-bird"></use>
        </svg>
      </span>
      <p class="Share-pitch">
        If you liked this article and think others should read it, please

        

        <a data-social-network="Twitter"
           data-social-action="tweet"
           data-social-target=""
           href="http://twitter.com/intent/tweet?text=Do%20We%20Actually%20Need%20Specificity%20In%20CSS%3F&url=http%3A%2F%2Fphilipwalton.com%2Farticles%2Fdo-we-actually-need-specificity-in-css%2F&via=philwalton">
           share it on Twitter</a>.
      </p>
    </div>
  </footer>

</article>


    