<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  
    Polyfilling CSS: A Proposal &mdash;
  
  Philip Walton
</title>

<!--[if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script><![endif]-->

<link href="//fonts.googleapis.com/css?family=Open+Sans:700,400|Noto+Serif:400italic,400" rel="stylesheet">

<script id="ga-setup">

// Google Analytics async snippet:
// http://goo.gl/3FPNDx
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;


// Create the GA tracker before doing any logging.
ga('create', 'UA-21292978-1', 'auto', {siteSpeedSampleRate: 100});



  // In non-production mode, simply log GA hits to the console.
  // Note, tasks must be set before sending the first hit
  ga(function(tracker) {
    tracker.set('sendHitTask', function() {
      // Throw to stop subsequent tasks.
      throw 'Abort tracking in non-production environments.'
    });
  });


// Track uncaught errors via Google Analytics.
window.onerror = function(message, url, line, col) {
  var desc = message + ' (line: ' + line + ', url: ' + url + ', col: '
      + col + ')';
  ga('send', 'exception', {
    exDescription: 'window.onerror: ' + desc,
    exFatal: false
  });
};

</script>


<link href="/assets/css/main.css" rel="stylesheet">
<link href="//feeds.feedburner.com/philipwalton" rel="alternate" title="Philip Walton" type="application/atom+xml">

<meta name="description" content="Thoughts on web development, open source, software architecture, and the future.">
<meta name="viewport" content="width=device-width, initial-scale=1">

<svg display="none">
  <defs>
    <path id="icon-twitter-bird" d="M34.7 5c1.7-1 2.8-2.5 3.4-4.4-1.6 0.9-3.3 1.6-5 2-1.6-1.7-3.6-2.6-5.8-2.6-2.2 0-4.2 0.7-5.7 2.3-1.6 1.6-2.3 3.4-2.3 5.8 0 0.6 0.1 1.2 0.2 1.8-6.9-0.4-12.6-3.2-16.9-8.5-0.7 1.2-1.1 2.7-1.1 4.1 0 3 1.2 5.2 3.6 6.8-1.2 0-2.5-0.4-3.6-1v0.1c0 2 0.6 3.7 1.8 5.2 1.2 1.5 2.7 2.5 4.6 2.8-0.6 0.1-1.2 0.2-2.1 0.2-0.4 0-0.9 0-1.5-0.1 0.5 1.5 1.4 2.8 2.8 3.8 1.4 1 3 1.5 4.7 1.6-3.1 2.5-6.4 3.7-10 3.7-0.5 0-1.1 0-2-0.1 3.7 2.2 7.8 3.4 12.4 3.4 3.6 0 6.8-0.7 9.8-2.1 3-1.4 5.4-3.2 7.3-5.4 1.8-2.2 3.3-4.7 4.3-7.4s1.6-5.4 1.6-8.1v-1c1.4-1 2.7-2.5 3.9-4.2-1.6 0.6-3.2 1.1-4.7 1.2z"></path>
    <path id="icon-rss" d="M16 0q6.6 0 11.3 4.7t4.7 11.3q0 6.6-4.7 11.3t-11.3 4.7-11.3-4.7-4.7-11.3 4.7-11.3 11.3-4.7zM10.7 24q1.1 0 1.9-0.8t0.8-1.9-0.8-1.9-1.9-0.8-1.9 0.8-0.8 1.9 0.8 1.9 1.9 0.8zM16.7 24h3.3q0-5-3.5-8.5t-8.5-3.5v3.3q3.6 0 6.1 2.5t2.5 6.1zM22.7 24h3.3q0-3.7-1.4-7t-3.8-5.7-5.7-3.8-7-1.4v3.3q6.1 0 10.4 4.3t4.3 10.4z"></path>
    <path id="icon-twitter" d="M16 0q6.6 0 11.3 4.7t4.7 11.3-4.7 11.3-11.3 4.7-11.3-4.7-4.7-11.3 4.7-11.3 11.3-4.7zM25.7 12.5q1.2-0.9 2.3-2.3-1.3 0.6-2.6 0.7 1.4-0.8 2-2.5-1.4 0.8-2.9 1.1-1.3-1.4-3.3-1.4-1.9 0-3.2 1.3t-1.3 3.2q0 0.6 0.1 1-5.7-0.3-9.4-4.8-0.6 1.1-0.6 2.3 0 2.4 2 3.8-1 0-2-0.6v0q0 1.6 1 2.9t2.6 1.6q-0.5 0.1-1.2 0.1-0.3 0-0.9-0.1 0.4 1.4 1.6 2.2t2.6 0.9q-2.6 2.1-5.6 2.1-0.4 0-1.1-0.1 3.1 2 7 2 3 0 5.5-1.2t4.1-3.1 2.4-4.1 0.9-4.6v-0.6z"></path>
    <path id="icon-github" d="M16 0q6.59 0 11.3 4.7t4.7 11.3q0 5.52-3.39 9.85t-8.61 5.67v-4.18q0-2.89-1.67-4.18 3.37-0.52 5.52-2.41t2.15-4.74q0-2.52-1.85-4.59 0.67-3.07-0.15-4.74-2.04 0.19-4.63 1.78-1.78-0.44-3.37-0.44t-3.37 0.44q-2.59-1.59-4.63-1.78-0.85 1.78-0.15 4.74-1.85 2.07-1.85 4.59 0 2.85 2.15 4.74t5.52 2.41q-0.85 0.63-1.3 1.82-0.67 0-1.37-0.13t-1.28-0.35-1.11-0.5-0.96-0.56-0.72-0.52-0.48-0.39l-0.15-0.15q-0.26-0.26-0.52-0.07-0.3 0.19-0.22 0.52 0.7 1.37 1.19 2 1.93 2.48 5.26 3.48v3.22q-5.22-1.33-8.61-5.67t-3.39-9.85q0-6.63 4.68-11.31t11.32-4.68z"></path>
  </defs>
</svg>


</head>
<body class="Site">

  <div class="Site-header">
    <header class="Header">
      <a class="Header-info" href="/" title="Home">
        <h1 class="Header-title">Philip Walton</h1>
        <p class="Header-tagline">Engineer at Google</p>
      </a>
      <a class="Header-photo" href="/" title="Home"></a>
      <div class="Header-social">
        <nav class="SocialNav">
  <a class="SocialNav-icon SocialNav-icon--twitter"
     href="https://twitter.com/philwalton"
     title="Twitter">
    <svg viewBox="0 0 32 32">
      <use xlink:href="#icon-twitter"></use>
    </svg>
  </a>
  <a class="SocialNav-icon SocialNav-icon--github"
     href="https://github.com/philipwalton"
     title="Github">
    <svg viewBox="0 0 32 32">
      <use xlink:href="#icon-github"></use>
    </svg>
  </a>
  <a class="SocialNav-icon SocialNav-icon--rss"
     href="http://feeds.feedburner.com/philipwalton"
     title="RSS">
    <svg viewBox="0 0 32 32">
      <use xlink:href="#icon-rss"></use>
    </svg>
  </a>
</nav>

      </div>
      <div class="Header-nav">
        <nav class="MainNav">
  <a href="/" title="Home">Home</a>
  <a href="/articles/" title="Articles">Articles</a>
  <a href="/about/" title="About">About</a>
</nav>

      </div>
    </header>
  </div>

  <div class="Site-contentContainer">
    <main class="Site-content">
      

<article role="article" class="hentry">

  <header class="ContentHeader">
    <h1 class="ContentHeader-title entry-title">Polyfilling CSS: A Proposal</h1>
    <time class="ContentHeader-date published"
        datetime="2015-09-21T09:48:08-07:00">
      September 21, 2015
    </time>
  </header>

  <div class="entry-content">
    
        <!--
A. Intro

B. How polyfilling CSS works
  1. Converting styles into an AST
  2. Modifying the AST to "fake" the missing features
  3. Outputting the new styles

C. Why polyfilling CSS is hard: the problems
  1. fetching and parsing the original CSS
    - extra requests
    - CORS resrictions
    - code size vs. parsing correctness
  2. Modifying the AST while maintaining the cascade order
    - how do you apply rules to individual elements?
    - inline styles don't work
  3. Updating styles in a performant way
    - do we need a virtual CSSOM similar to how React has a virtual DOM?

D. Solutions
  1. parse the CSS server-side
    - create an AST
  2. load the stylesheet via JavaScript
    - the JS code stores the AST and knows how to convert it to CSS
  3. polyfills are plugins that update the AST via the standard library
  4. The standard library manages normalizing selector specificity
  5. The standard library knows how to update the CSSOM to have minimal performance impact.
-->
<!--
A. Intro
B. Why polyfilling CSS is hard: the problems
  1. downloading the CSS
    - extra requests
    - CORS resrictions
  2. parsing the CSS
    - code size vs. parsing correctness
  3. applying the polyfills
C. Types of CSS polyfills
  1. rewriting rules
    - replacing values
    - replacing pseudo-classes with real classes
    - replacing pseudo-elements with real elements
  2. targeting elements
    - replacing generic rules with per-element rules
    - normalizing specificity
D. The solutions (a proposal)
  1. parse the CSS server-side
    - create an AST
  2. load the stylesheet via JavaScript
    - the JS code stores the AST and knows how to convert it to CSS
  3. polyfills as plugins to a standard library
    - manage rewriting and specificity normalization globally
-->
<p>I think it’s fair to say that the biggest reason we haven’t seen the same boom in the adoption of new CSS features as we’ve seen in JavaScript recently is a lack of a reasonable and performant ways to polyfill CSS.</p>
<p>As a result, instead of developers clammoring for new features and contributing to the specification process, we tend to see people completely ignore these things because in their mind: <em>I won’t be able to use that for years!</em></p>
<p>I also get the sense that many developers are waiting until all browsers become auto-updating, assuming that once that happens polyfills will pretty much be unneccessary, and all new features will magically become available at the same time.</p>
<p>The truth is that browsers will always be adopting and implementing new features at varying speeds and at varying degrees of correctness. And without a good way to polyfill those features, the web will be forced to the lowest common denominator.</p>
<p>In this article I’m going to explain why polyfilling CSS has traditionally been such a difficult thing to do, and why almost all existing polyfills do it wrong. I’m also going to propose an alternative that I hope, if nothing else, will push this conversation forward—I think it’s a very important conversation to have.</p>
<h2>Why polyfilling CSS is hard</h2>
<p>To summarize the problem: when writing any CSS polyfill, the vast majority of your time and code is going to spent on things that have absolutely nothing to do with the feature you’re trying to implement.</p>
<p>The reason for this is that every CSS polyfill requires access to the original CSS. Even for browers that expose the CSS Object Model (CSSOM) via <code>document.styleSheets</code>, access to the original CSS is still needed because, if the browser doesn’t understand the feature you’re trying to polyfill, it’s not going to include it in <code>document.styleSheets</code>.</p>
<p>Because of this, every CSS polyfill needs to do at least the following things:</p>
<ul>
<li>Make one or more extra requests to fetch all CSS files.</li>
<li>Parse the stylesheets, looking for relavant rules and declarations.</li>
<li>Determine how to update those rules so they apply to their matching elements while still maintaining their proper cascade order.</li>
</ul>
<h3>Fetching the original CSS</h3>
<p>The way most CSS polyfills get access to the original CSS code is to scan the current document for <code>&lt;link&gt;</code> tags with the <code>rel=&quot;stylesheet&quot;</code> attribute, make an AJAX request to download those stylesheets.</p>
<p>There are two main problems with this approach:</p>
<ul>
<li>You have to do an extra request per stylesheet,<sup>[<a href="#footnote-1">1</a></sup> which means you either have to delay rendering or have the dreaded <a href="#">FOUC</a>.</li>
<li>If any of the stylesheets are hosted on a CDN or third-party domain, this won’t work unless CORS is enabled.</li>
</ul>
<h3>Parsing the CSS</h3>
<p>Once you have the original CSS code, you need to parse it to look for the features you want to polyfill.</p>
<p>This poses another problem. At first glance, CSS seems like it would be a pretty simply language to parse, but the reality is there are numerous edge cases that must be considered. The logic required to properly parse CSS text is likely far more complicated than the actual feature you’re trying to polyfill, making the whole endever seem pointless.</p>
<p>As a result, most CSS polyfills make compromises, and they sacrific parsing accuracy in favor of smaller file size. This works in many cases but can lead to some pretty annoying bugs. For example, consider a CSS polyfill for the <code>rem</code> unit that simply does a find and replace using the regex <code>/(\d+)rem/g</code>. If it encountered the following rule, it would fail:</p>
<pre><code class="language-css"><span class="hljs-tag">body</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(<span class="hljs-string">'http://example.com/images/<mark>5rem</mark>.gif'</span>) repeat-x</span></span>;
}</span>
</code></pre>
<h3>Applying the polyfill logic</h3>
<p>At this point, a CSS polyfill has done a lot of work. But it hasn’t even started the process of actually polyfilling the feature.</p>
<p>This extra work can be pretty wasteful, especially if you want to include more than one polyfill on the same page. It makes absolutely no sense for several different polyfills to all be making AJAX requests for the same CSS file(s) and then running their own, distinct parsing logic on the returned CSS text.</p>
<p>In an ideal world, CSS polyfill authors wouldn’t have to worry about downloading and parsing the document’s stylesheets. In an ideal world, this could all be handled by a common base library, and then polyfill authors would simply plug into a structured CSS object, make the modifications they need, and then pass the object onto the next polyfill.</p>
<p>There are a variety of different types or categories of CSS polyfills, but at their core they all have many things in common. The accept some CSS text that contains the features they want to polyfill, they run some logic, and then they output new CSS that approximates (as closely as possible) what native support would look like.</p>
<!--
Sure, [CSS Polyfills exist](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#css-core-modules), but they pretty much all exist in isolation. What I mean by that is there's a certain amount of work that must go into polyfillying CSS, and every existing CSS polyfill repeats this effort.




When you polyfill a feature in JavaScript, the process is pretty simple. I mean, obviously the implementation of certain polyfills is complex, but the concept is easy. You check to see if a value exists, and if it doesn't, you create it.

For example, a polyfill to add promises to unsporting browsers looks basicaly like this:

```js
window.Promise = window.Promise || /* Promise code here... */
```

JavaScript polyfills allow your code to run as-is&mdash;without having to change it.

In CSS it's not quite so simple. Browsers don't provide access to their internal styling mechanisms, so there's no way to simply say: *Hey, do you support CSS grids? No? Okay, then please add this C++ code to your rendering logic, so my CSS works as expected.*

Since browser rendering logic isn't exposed to website developers, CSS polyfills *require* rewriting the CSS. Sometimes this can be done server-side, as in the case of [autoprefixer](#) or other [PostCSS](#) plugins, but in many cases information about the browsing context (e.g. viewport dimensions, element position, font-size settings, etc) are needed, and thus rewriting the CSS has to happen client-side.

What makes this even harder is that rewriting the CSS can't happen from the browser's CSS Object Model (CSSOM). When CSS encounters a syntax error or any rule it doesn't understand, it simply ignores it. For example, consider the following CSS rule:

```css
p {
  display: magic;
}
```

If you were to log the `cssText` value for this rule in `document.styleSheets`, you'd get `p { }`. Notice that the `display: magic` declaration is nowhere to be found.

This means that in order to rewrite the CSS, you have to have access to the original code, not just what the browser gives you.
-->
<h2>Type of CSS polyfills</h2>
<!--
  1. rewriting rules
    - replacing values
    - replacing pseudo-classes with real classes
    - replacing pseudo-elements with real elements
  2. targeting elements
    - replacing generic rules with per-element rules
    - normalizing specificity
-->
<p>All CSS polyfills require converting original CSS into transformed CSS where the old property/value pairs, selectors, or even entire rules have been replaced with new values, selectors, or rules that the current browser understands. In some cases this only needs to happen at page load, but depending on what feature is being polyfilled, it may need to happen additional times in response to user interaction.</p>
<p>There are three main categories of CSS polyfills, and I’ll go over each of them in order, starting with the simplest.</p>
<h3>Polyfills that replace values</h3>
<p>The easiest polyfills to write are ones that simply convert an unknown value into a known value. The don’t require traversing the DOM or updating any elements.</p>
<p>A good example of this type of polyfill would be for the <code>rem</code> unit. All the needs to happen is for the browser to figure out what the <code>1em</code> is in pixels on the root element, and then replace all <code>rem</code> delcaration with the corresponding value in pixels.</p>
<p>Replacements only happen in value declarations which means the cascade order is not affected at all.</p>
<h3>Polyfills that update selectors</h3>
<p>Polyfills that update selectors are slightly more complex because they require some DOM manipluation, but they’re still relatively straightforward.</p>
<p>Consider a polyfill for the <a href="http://www.w3.org/TR/2011/WD-selectors4-20110929/#local-pseudo"><code>:local-link</code></a> pseudo-class:</p>
<pre><code class="language-css"><span class="hljs-tag">nav</span> <span class="hljs-rule"><span class="hljs-attribute">a</span>:<span class="hljs-value">local-link { }
</span></span></code></pre>
<p>To make this work, you could simply determine which links on the page are local, add the class <code>local-link</code> to them (or an attribute), and update the selector as follows:</p>
<pre><code class="language-css"><span class="hljs-tag">nav</span> <span class="hljs-tag">a</span><span class="hljs-class">.local-link</span> <span class="hljs-rules">{ }</span>
<span class="hljs-tag">nav</span> <span class="hljs-tag">a</span><span class="hljs-attr_selector">[data-local-link]</span> <span class="hljs-rules">{ }</span>
</code></pre>
<p>Since class selectors, pseudo-class selectors, and attribute selectors all carry the same specificity, the cascade order is not affected by this replacement.</p>
<h3>Polyfills that add new rules</h3>
<p>By far the hardest polyfills to write are for features that affect individual elements differently. The reason they’re hard is because you can’t simply rewrite rules, you have to add new ones. And there’s no easy or side-effect-free way to maintain the cascade order when adding new rules that target individual elements.</p>
<p>To make it easier to understand why this is hard, let me propose a hypothetical new CSS length keyword called <code>random</code>. For the purposes of this example, random gets computed to a length between 0% and 100%, and it applies differently to each matching element.</p>
<p>Consider how you might go about implementing the <code>random</code> keyword polyfill. The following HTML and CSS should help to illustrate why this is challenging:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"nav"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/contact"</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<pre><code class="language-css"><span class="hljs-class">.nav</span> <span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> random
}
.nav li:hover {
  width: auto</span></span>;
}</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (max-width: <span class="hljs-number">30em</span>) </span>{
  <span class="hljs-class">.nav</span> <span class="hljs-tag">li</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-function">max</span>(random, <span class="hljs-number">50%</span>)</span></span>;
  }</span>
}
</code></pre>
<p>In the above CSS, each list item is going to have a random width unless the viewport is smaller than <code>30em</code>, in which case the width will be the larger of the <code>random</code> value or <code>50%</code>. If the user is hovering over the list item, its width will go back to being <code>auto</code>.</p>
<p>In CSS there are three basic types of polyfills:</p>
<ul>
<li>Polyfills for new properties/values.</li>
<li>Polyfills for new selectors/combinators.</li>
<li>Polyfills for new @rules.</li>
</ul>
<p>For each of these types, there are polyfills that can be done the easy way, and there are polyfills that require the hard way.</p>
<h3>The easy way (per-rule polyfills)</h3>
<p>Many polyfills are easy in the sense that they just require rewriting the CSS. For example, consider what it would look like to polyfill the <code>rem</code> unit in browsers that don’t support rems. All that’s required is figuring out the value of <code>1rem</code> in pixels and then replacing all occurances of <code>rem</code>-based length declarations with the equivalent pixel value, and then updating the CSS.</p>
<h3>The hard way (per-element polyfills)</h3>
<p>Where things get a lot tricker is when a particular value computes to something different for each matching element. For example, imagine if CSS introduced a new <code>random</code> keyword that could be used anywhere a length value was accepted.</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> random</span></span>;
}</span>
</code></pre>
<p>In this case each element with the class <code>horizontal-bar</code> will have a different width, so you can’t simply rewrite <code>width: random</code> to something like <code>width: 42%</code> (or whatever value was randomly determined) because then all</p>
<h3>Specificity problems</h3>
<p>At first you might assume that you could solve the per-element issue by applying inline styles to each matching element (as a lot of polyfills do today). The problem with this approach is inline elements have a much greater specificity than basic CSS rules.</p>
<p>Continuing with the <code>random</code> keyword polyfill, consider the following CSS:</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> random</span></span>;
}</span>

<span class="hljs-rule"><span class="hljs-attribute">.horizontal-bar</span>:<span class="hljs-value">first-child {
  width: auto</span></span>;
}
</code></pre>
<p>Any CSS polyfill that applied inline styles for the first rule would be doing so incorrectly for any elements that matched <code>.horizontal-bar:first-child</code>. Any CSS polyfill that takes rules out of their original order or changes their specificity in relation to the other rules (which includes using inline styles) is fundamentally broken.</p>
<h2>Solving the specificity problem</h2>
<p>But if you’re attempting to write a CSS polyfill that requires per-element modification and you’re not allowed to reorder rules or change their specificity in relation to other rules, how can this be done?</p>
<h3>Targeting individual elements using CSS</h3>
<p>One way to target individual elements is to give them all a unique ID and rewrite the selector to use these IDs (obviously this changes the specificity, I’ll get to that in a second):</p>
<p>So instead of this:</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> random</span></span>;
}</span>
</code></pre>
<p>You’d search the DOM for all elements that match <code>.horizontal-bar</code>, give them each unique IDs, and write the selector. If three elements matched the query, you’d have something like this:</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">26%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">85%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id3</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">41%</span></span></span>;
}</span>
</code></pre>
<h3>Normalizing the specificity</h3>
<p>As I mentioned above, rewriting rules with ID selectors obviously changes their specificity. However, this is only a problem if the specificity changes <em>relative to the specificity of other rules</em>. If you rewrite all rules in such a way as to keep their relative specificities the same, it wouldn’t be a problem.</p>
<p>Consider the original problem I show above:</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> random</span></span>;
}</span>

<span class="hljs-rule"><span class="hljs-attribute">.horizontal-bar</span>:<span class="hljs-value">first-child {
  width: auto</span></span>;
}
</code></pre>
<p>Rewriting these rules this way would obviously not work because the IDs used in the first three rules would trump the fourth rule:</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">26%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">85%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id3</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">41%</span></span></span>;
}</span>

<span class="hljs-rule"><span class="hljs-attribute">.horizontal-bar</span>:<span class="hljs-value">first-child {
  width: auto</span></span>;
}
</code></pre>
<p>But if you rewrote them as follows, you’d be fine. In this case you’re increasing the specificity of each rule by exactly one ID.</p>
<pre><code class="language-css"><span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">26%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">85%</span></span></span>;
}</span>
<span class="hljs-class">.horizontal-bar</span><span class="hljs-id">#id3</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">41%</span></span></span>;
}</span>

<span class="hljs-id">#base</span> <span class="hljs-rule"><span class="hljs-attribute">.horizontal-bar</span>:<span class="hljs-value">first-child {
  width: auto</span></span>;
}
</code></pre>
<aside class="Footnotes">
  <h1 class="Footnotes-title">Footnotes:</h1>
  <ol class="Footnotes-items">
    <li id="footnote-1">If the browser has already made a request for this stylesheet, a second request will usually return a cached version, so the performance impact isn't quite as bad as it might originally seem, though it's still not ideal.</li>
  </ol>
</aside>
<h2>Solution: parse the CSS server side</h2>
<p>The more I think about CSS polyfills the more I’m convinced that parsing the CSS in the browser is simply not an option. I’ve already mentioned that it’s slow. The other big issue is every single polyfill duplicates this effort. There’s not common polyfill engine to plug in to.</p>
<p>On the server-side, however, the issue of parser code size isn’t a problem. CSS parsers like <a href="#">PostCSS</a> have been battle-tested and can handle just about any hacky or abnormal CSS you can through at it.</p>
<p>When PostCSS parses a CSS string, it returns an abstract syntax tree (AST) representation of the CSS. The code required to create that AST isn’t trivial, but the code required to turn it back into CSS is!</p>
<p>Instead of serving a CSS file to the browser, you can just as easily serve a JavaScript file that contains the AST and the small snippet of code required to convert the AST to CSS, create a <code>&lt;style&gt;</code> tag with that CSS in it, and add the <code>&lt;style&gt;</code> tag to the document.</p>
<p>To put that another way, instead of this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"styles.css"</span>&gt;</span>
</code></pre>
<p>You’d have this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"styles.css.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<h3>The problem of size</h3>
<p>For the curious, here’s a very simple CSS file and it’s corresponding AST:</p>
<pre><code class="language-css"><span class="hljs-tag">html</span>,
<span class="hljs-tag">body</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>;
}</span>

<span class="hljs-tag">body</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">font</span>:<span class="hljs-value"> <span class="hljs-number">1rem</span>/<span class="hljs-number">1</span> serif</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">1rem</span></span></span>;
}</span>
</code></pre>
<pre><code class="language-json">{
  "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"root"</span></span>,
  "<span class="hljs-attribute">nodes</span>": <span class="hljs-value">[
    {
      "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"rule"</span></span>,
      "<span class="hljs-attribute">selector</span>": <span class="hljs-value"><span class="hljs-string">"html,\nbody"</span></span>,
      "<span class="hljs-attribute">nodes</span>": <span class="hljs-value">[
        {
          "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"decl"</span></span>,
          "<span class="hljs-attribute">prop</span>": <span class="hljs-value"><span class="hljs-string">"height"</span></span>,
          "<span class="hljs-attribute">value</span>": <span class="hljs-value"><span class="hljs-string">"100%"</span>
        </span>}
      ]
    </span>},
    {
      "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"rule"</span></span>,
      "<span class="hljs-attribute">selector</span>": <span class="hljs-value"><span class="hljs-string">"body"</span></span>,
      "<span class="hljs-attribute">nodes</span>": <span class="hljs-value">[
        {
          "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"decl"</span></span>,
          "<span class="hljs-attribute">prop</span>": <span class="hljs-value"><span class="hljs-string">"font"</span></span>,
          "<span class="hljs-attribute">value</span>": <span class="hljs-value"><span class="hljs-string">"1rem/1 serif"</span>
        </span>},
        {
          "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"decl"</span></span>,
          "<span class="hljs-attribute">prop</span>": <span class="hljs-value"><span class="hljs-string">"margin"</span></span>,
          "<span class="hljs-attribute">value</span>": <span class="hljs-value"><span class="hljs-string">"1rem"</span>
        </span>}
      ]
    </span>}
  }
}
</span></code></pre>
<p>Obviously the AST is quite a bit more verbose. At first this may seem like a big problem, but with gzip, msot of this extra weight goes away.</p>
<p>For example, I took the current version of bootstrap.css is 120K and its corresponding AST is 600K. However, once you minify and gzip both, they’re 21K and 24K respectively, a much more manageable difference.</p>
<h3>The problem of requiring JavaScript</h3>
<p>I’m sure the use of JavaScript instead of CSS is raising some eyebrows right now. <em>What if JavaScript is turned off? What if there’s an error? Will my page just not get any styles?</em></p>
<p>The answer to all of these questions is no.</p>
<p>In the case JavaScript be turned off, you can link to the original CSS file in a <code>&lt;noscript&gt;</code> tag. And to deal with JavaScript errors, all the polyfill code can be wrapped in a <code>try/catch</code> block that simply restore the original CSS as well in the case of any issue.</p>
<p>Though I admit it may seem a bit strange, it’s actually a poster-child example for progressive enhancement.</p>

      
  </div>

  <footer class="entry-unrelated">
    <div class="Share">
      <span class="Share-figure">
        <svg viewBox="0 0 39 32">
          <use xlink:href="#icon-twitter-bird"></use>
        </svg>
      </span>
      <p class="Share-pitch">
        If you liked this article and think others should read it, please

        

        <a data-social-network="Twitter"
           data-social-action="tweet"
           href="http://twitter.com/intent/tweet?text=Polyfilling%20CSS%3A%20A%20Proposal&url=http%3A%2F%2Fphilipwalton.com%2Farticles%2Fpolyfilling-css%2F&via=philwalton">
           share it on Twitter</a>.
      </p>
    </div>
  </footer>

</article>


    </main>
  </div>

  <script src="/assets/javascript/main.js"></script>

<!-- Load GA after the `window.ga` is initialized or you'll get errors. -->


  <script async src="//www.google-analytics.com/analytics_debug.js"></script>


<!-- Load HTML Inspector in dev mode. -->


  <script src="//cdnjs.cloudflare.com/ajax/libs/html-inspector/0.8.2/html-inspector.js"></script>
  <script>
    HTMLInspector.rules.extend("unused-classes", function(config) {
      config.whitelist = config.whitelist.concat([/^wf-/]);
      return config;
    });

    HTMLInspector.rules.extend("script-placement", function(config) {
      config.whitelist = config.whitelist.concat(['#ga-setup']);
      return config;
    });

    // start the inspection
    HTMLInspector.inspect();
  </script>



</body>
</html>
