
      

<article role="article" class="hentry">

  <header class="ContentHeader">
    <h1 class="ContentHeader-title entry-title">Why I'm Excited About Native CSS Variables</h1>
    <time class="ContentHeader-date published"
        datetime="2015-11-03T17:28:56-08:00">
      November 3, 2015
    </time>
  </header>

  <div class="entry-content">
    
        <p>A few days ago CSS variables—more accurately known as CSS custom properties—shipped in Chrome Canary.</p>
<p>When Chrome engineer <a href="https://twitter.com/addyosmani">Addy Osmani</a> first tweeted about the release, he was met with a surprising amount of <a href="https://twitter.com/joshlangner/status/661608288707026944">negativity</a>, <a href="https://twitter.com/kuizinas/status/661600615911526401">hostility</a>, and <a href="https://twitter.com/DanTup/status/661609987047866368">skepticism</a>. At least, it was surprising to me, given how excited I am about this feature.</p>
<p>After a quick scan of the responses, it was clear that 99% of the complaints focused on one of these two things:</p>
<ul>
<li>The syntax is “ugly” and “verbose”.</li>
<li>Sass already does this, so why should I care?</li>
</ul>
<p>For the record, I <em>do</em> understand why people have this reaction. I mean, if you’re used to doing this:</p>
<pre><code class="language-scss"><span class="hljs-variable">$linkColor</span><span class="hljs-value">: red;</span>

<span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: <span class="hljs-variable">$linkColor</span>;</span>
}
</code></pre>
<p>and then you’re told to do this:</p>
<pre><code class="language-css"><span class="hljs-pseudo">:root</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--linkColor</span>:<span class="hljs-value"> red</span></span>;
}</span>

<span class="hljs-tag">a</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">var</span>(--linkColor)</span></span>;
}</span>
</code></pre>
<p>I get why you’d be disappointed—and if that’s all CSS variables did, I’d be disappointed too.</p>
<p>If CSS variables were <em>just</em> a way to reference stored values, and they didn’t offer anything above and beyond what we can already do with preprocessors, there would be little reason for them to exist (and no reason to have the syntax they do).</p>
<p>But the reality is CSS variables can do <em>so much</em> more than that. In fact, I think it does them a disservice to even call them variables at all. They’re custom properties, which gives them an entirely different set of superpowers.</p>
<p>In this article I’m going to highlight some of the limitations of preprocessor variables and show that these limitations don’t apply to custom properties. I’ll also demo some of the new design patterns that custom properties will enable: things like responsive, cascading properties and contextual styling via React-style, one-way data flow.</p>
<h2 id="the-limitations-of-preprocessor-variables">The limitations of preprocessor variables</h2>
<p>CSS preprocessors can do some pretty amazing things. Even if you know that they ultimately just spit out raw CSS, they can still feel magical at times.</p>
<p>That being said, they definitely have their limitations, and sometimes the appearance of dynamic power can make these limitations surprising, especially to new users.</p>
<h3 id="preprocessor-variables-arent-live">Preprocessor variables aren’t live</h3>
<p>Perhaps the most common example of a preprocessor limitation that surprises new users is the inability to define variables or use <code>@extend</code> inside a media query.</p>
<p>Since this article is about variables, I’ll focus on the former:</p>
<pre><code class="language-scss"><span class="hljs-variable">$gutter</span><span class="hljs-value">: <span class="hljs-number">1em</span>;</span>

<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width:<span class="hljs-preprocessor"> 30em</span>) {</span>
  <span class="hljs-variable">$gutter</span><span class="hljs-value">: <span class="hljs-number">2em</span>;</span>
}

<span class="hljs-class">.Container</span> {
  <span class="hljs-attribute">padding</span><span class="hljs-value">: <span class="hljs-variable">$gutter</span>;</span>
}
</code></pre>
<p>If you compile the above code with Sass, you’ll see that the media query block simply gets discarded and the variable assignment ignored. While it’s technically <em>possible</em> for a preprocessor to make conditional variable declarations work, doing so would be technically challenging and require enumerating all possible permutations—exponentially increasing the final size of your CSS.</p>
<p>Since it’s not possible to change a variable based on the matching <code>@media</code> rule, the only option is to assign a unique variable per media query, and code out each version separately. More on this later.</p>
<h3 id="preprocessor-variables-dont-cascade">Preprocessor variables don’t cascade</h3>
<p>Whenever you use variables, the question of scope inevitably comes into play. Should this variable be global? Should it be scoped to the file/module? Should it be scoped to the block? These are all questions I hear asked frequently by Sass developers.</p>
<p>As it turns out, there’s another way to scope variables that ends up being far more useful: scoping them to a DOM subtree. And since preprocessors don’t run in the browser and never see the markup, they can’t do this.</p>
<p>If you’re wondering why you’d want to scope a variable to a DOM subtree, consider the following example:</p>
<pre><code class="language-css"><span class="hljs-class">.alert</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> lightyellow</span></span>; }</span>
<span class="hljs-class">.alert</span><span class="hljs-class">.info</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> lightblue</span></span>; }</span>
<span class="hljs-class">.alert</span><span class="hljs-class">.error</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> orangered</span></span>; }</span>

<span class="hljs-class">.alert</span> <span class="hljs-tag">button</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border-color</span>:<span class="hljs-value"> <span class="hljs-function">darken</span>(background-color, <span class="hljs-number">25%</span>)</span></span>;
}</span>
</code></pre>
<p>The above code isn’t valid CSS, but you should be able to understand what it’s trying to accomplish. The idea is that <code>&lt;button&gt;</code> elements should be able to adapt to the properties of their parent context. Regardless of what background color is applied to <code>.alert</code>, the button inside of it should be able to have a border color that matches.</p>
<p>There are tons of use cases for this type of feature, but I think the most compelling is to ensure text is always readable and sufficiently contrasts with the background.</p>
<p>Since preprocessor variables aren’t CSS declarations (property-value pairs), they don’t cascade. And they don’t inherit to child elements.</p>
<h3 id="preprocessor-variables-arent-interoperable">Preprocessor variables aren’t interoperable</h3>
<p>This is a relatively obvious downside of preprocessors, but I mention it because I think it’s important. If you’re building a site with PostCSS and you want to use a third-party component that’s only themeable via Sass, you’re out of luck.</p>
<p>It’s not possible (or at least not easy) to share preprocessor variables across different toolsets or with third-party stylesheets hosted on a CDN.</p>
<p>Native CSS custom properties will work with any CSS preprocessor or plain CSS file. The reverse is not usually true.</p>
<h2 id="how-custom-properties-are-different">How custom properties are different</h2>
<p>I mentioned above that CSS variables aren’t actually variables in the traditional sense, they’re custom properties, which makes them quite a bit more powerful.</p>
<p>But what does that mean?</p>
<p>To answer that question, I think it’s helpful to examine how normal CSS properties work, specifically the inheritable properties.</p>
<p>Think about what happens when you set <code>color: gray</code> or <code>font-size: .875em</code> on the <code>&lt;body&gt;</code> element. All descendants of <code>&lt;body&gt;</code>, who don’t specify their own colors or font sizes, inherit those values.</p>
<p>Since custom properties are just regular, inheritable properties, all of these concepts apply to them as well. And all the mechanisms you can use to define or override regular properties apply to custom properties too.</p>
<p>To put that more technically: <em>custom properties cascade!</em></p>
<p>Back to the <code>color</code> and <code>font-size</code> example, consider what happens when the following rule is added to the CSS:</p>
<pre><code class="language-css"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width: <span class="hljs-number">48em</span>) </span>{
  <span class="hljs-tag">body</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">1.25em</span></span></span>;
  }</span>
}
</code></pre>
<p>When the above <code>@media</code> rule matches, the <code>font-size</code> value becomes <code>1.25em</code> and all descendants of <code>&lt;body&gt;</code> will update accordingly. Since the new declaration didn’t override the <code>color</code>, the original declaration still applies.</p>
<p>The same thing happens to custom properties. Just like regular properties, their values are live! Any time you define a custom property in a media query or class declaration, as soon as that declaration matches or stops matching, the custom property value automatically updates throughout the site.</p>
<h2 id="using-custom-properties">Using custom properties</h2>
<p>Here’s a basic example of how custom properties work. In the following code, the custom property <code>--tableStripeColor</code> is defined on the <code>&lt;table&gt;</code> element, and then odd table rows reference that property in their background color declaration:</p>
<pre><code class="language-css"><span class="hljs-tag">table</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--tableStripeColor</span>:<span class="hljs-value"> lightgray</span></span>;
}</span>
<span class="hljs-rule"><span class="hljs-attribute">tr</span>:<span class="hljs-value"><span class="hljs-function">nth-child</span>(odd) {
  background: <span class="hljs-function">var</span>(--tableStripeColor)</span></span>;
}
</code></pre>
<p>An important distinction to note is that the <code>tr:nth-child(odd)</code> elements aren’t actually looking up the value of <code>--tableStripeColor</code> on the <code>&lt;table&gt;</code> element, they don’t actually know or care where the property was initially defined. They’re looking up the property on themselves, and they find it on themselves because the property/value declaration inherits from the <code>&lt;table&gt;</code> element to the <code>&lt;tr&gt;</code> element.</p>
<p>Now suppose we decide we don’t want rows in the table head to be striped. Since the <code>&lt;thead&gt;</code> element is child of <code>&lt;table&gt;</code> and a parent of the rows we don’t want to stripe, we can prevent those rows from getting the <code>--tableStripeColor</code> property by resetting it to its initial value.</p>
<pre><code class="language-css"><span class="hljs-tag">table</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--tableStripeColor</span>:<span class="hljs-value"> lightgray</span></span>;
}</span>
<span class="hljs-tag">thead</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--tableStripeColor</span>:<span class="hljs-value"> initial</span></span>;
}</span>
<span class="hljs-rule"><span class="hljs-attribute">tr</span>:<span class="hljs-value"><span class="hljs-function">nth-child</span>(odd) {
  background: <span class="hljs-function">var</span>(--tableStripeColor)</span></span>;
}
</code></pre>
<h3 id="setting-defaults">Setting defaults</h3>
<p>The <code>var()</code> function takes an optional second argument that can be used as a fallback in the event that the custom property isn’t defined. For example, the following declaration would allow third-party users to define a <code>--linkColor</code> property, but if no such property were found, the links would be orange.</p>
<pre><code class="language-css"><span class="hljs-tag">a</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">var</span>(--linkColor, orange)</span></span>;
}</span>
</code></pre>
<p>Another way to set default values is to define properties on the root element:</p>
<pre><code class="language-css"><span class="hljs-pseudo">:root</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--linkColor</span>:<span class="hljs-value"> orange</span></span>;
}</span>

<span class="hljs-tag">a</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">var</span>(--linkColor)</span></span>;
}</span>
</code></pre>
<p>Though these two examples may seem to be doing the same thing, they’re subtly different. In the second example, a user could reset the property for all links in the sidebar with the following rule:</p>
<pre><code class="language-css"><span class="hljs-class">.sidebar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--linkColor</span>:<span class="hljs-value"> initial</span></span>;
}</span>
</code></pre>
<p>Such a rule in the first example would still produce orange links because the default is defined on <code>&lt;a&gt;</code> elements rather than on <code>:root</code>.</p>
<h2 id="real-life-examples">Real-life examples</h2>
<p>There are a lot of great examples I could have chosen to showcase the power of CSS custom properties, but in the interest of not letting this article get too long, I settled on just two.</p>
<p>I picked these examples because they’re not just theoretical, they’re actual challenges I’ve faced in the past. I can distinctly remember trying to make them work in Sass or PostCSS, and it just wasn’t possible.</p>
<p>With custom properties, now it is.</p>
<h3 id="responsive-properties-with-media-queries">Responsive properties with media queries</h3>
<p>Probably the most compelling use-case for custom properties is the ability to automatically update the property values in response to the matched media.</p>
<p>Consider a site with a standard gutter variable that defines the default spacing between items in the layout as well as the default padding for all the various sections on the page.</p>
<p>In many cases, you want the value of this gutter to be different depending on how big the browser window is. On large screens you want a lot of space between items (a lot of breathing room), but on smaller screens you can’t afford that much space, so the gutters need to be smaller.</p>
<p>Since CSS preprocessors ultimately produce static files, the only way to do this today is to explicitly write out all possible variations. Consider the following Sass code that defines <code>$gutterSm</code>, <code>$gutterMd</code>, and <code>$gutterLg</code> variations:</p>
<pre><code class="language-css"><span class="hljs-comment">/* Declares three gutter values, one for each breakpoint */</span>

$<span class="hljs-rule"><span class="hljs-attribute">gutterSm</span>:<span class="hljs-value"> <span class="hljs-number">1em</span></span></span>;
$<span class="hljs-rule"><span class="hljs-attribute">gutterMd</span>:<span class="hljs-value"> <span class="hljs-number">2em</span></span></span>;
$<span class="hljs-rule"><span class="hljs-attribute">gutterLg</span>:<span class="hljs-value"> <span class="hljs-number">3em</span></span></span>;

<span class="hljs-comment">/* Base styles for small screens, using $gutterSm. */</span>

<span class="hljs-class">.Container</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span> auto</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"> <span class="hljs-number">60em</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterSm</span></span>;
}</span>
<span class="hljs-class">.Grid</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> flex</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> -$gutterSm <span class="hljs-number">0</span> <span class="hljs-number">0</span> -$gutterSm</span></span>;
}</span>
<span class="hljs-class">.Grid-cell</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">flex</span>:<span class="hljs-value"> <span class="hljs-number">1</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterSm <span class="hljs-number">0</span> <span class="hljs-number">0</span> $gutterSm</span></span>;
}</span>

<span class="hljs-comment">/* Override styles for medium screens, using $gutterMd. */</span>

<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width: <span class="hljs-number">30em</span>) </span>{
  <span class="hljs-class">.Container</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterMd</span></span>;
  }</span>
  <span class="hljs-class">.Grid</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> -$gutterMd <span class="hljs-number">0</span> <span class="hljs-number">0</span> -$gutterMd</span></span>;
  }</span>
  <span class="hljs-class">.Grid-cell</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterMd <span class="hljs-number">0</span> <span class="hljs-number">0</span> $gutterMd</span></span>;
  }</span>
}

<span class="hljs-comment">/* Override styles for large screens, using $gutterLg. */</span>

<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width: <span class="hljs-number">30em</span>) </span>{
  <span class="hljs-class">.Container</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterLg</span></span>;
  }</span>
  <span class="hljs-class">.Grid</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> -$gutterLg <span class="hljs-number">0</span> <span class="hljs-number">0</span> -$gutterLg</span></span>;
  }</span>
  <span class="hljs-class">.Grid-cell</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> $gutterLg <span class="hljs-number">0</span> <span class="hljs-number">0</span> $gutterLg</span></span>;
  }</span>
}
</code></pre>
<p>To accomplish the exact same thing using custom properties, you just define your styles once, and you reference a single <code>--gutter</code> property. Then, as the matched media changes, you update the value of <code>--gutter</code> and everything responds accordingly.</p>
<pre><code class="language-scss"><span class="hljs-comment">/* Declares what `--gutter` is at each breakpoint */</span>

<span class="hljs-pseudo">:root</span> { --gutter<span class="hljs-value">: <span class="hljs-number">1.5em</span>;</span> }

<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width:<span class="hljs-preprocessor"> 30em</span>) {</span>
  <span class="hljs-pseudo">:root</span> { --gutter<span class="hljs-value">: <span class="hljs-number">2em</span>;</span> }
}
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width:<span class="hljs-preprocessor"> 48em</span>) {</span>
  <span class="hljs-pseudo">:root</span> { --gutter<span class="hljs-value">: <span class="hljs-number">3em</span>;</span> }
}

<span class="hljs-comment">/*
 * Styles only need to be defined once because
 * the custom property values automatically update.
 */</span>

<span class="hljs-class">.Container</span> {
  <span class="hljs-attribute">margin</span><span class="hljs-value">: <span class="hljs-number">0</span> auto;</span>
  <span class="hljs-attribute">max-width</span><span class="hljs-value">: <span class="hljs-number">60em</span>;</span>
  <span class="hljs-attribute">padding</span><span class="hljs-value">: <span class="hljs-function">var</span>(--gutter);</span>
}
<span class="hljs-class">.Grid</span> {
  --gutterNegative<span class="hljs-value">: <span class="hljs-function">calc</span>(<span class="hljs-number">1</span> * <span class="hljs-function">var</span>(--gutter));</span>
  <span class="hljs-attribute">display</span><span class="hljs-value">: flex;</span>
  <span class="hljs-attribute">margin-left</span><span class="hljs-value">: <span class="hljs-function">var</span>(--gutterNegative);</span>
  <span class="hljs-attribute">margin-top</span><span class="hljs-value">: <span class="hljs-function">var</span>(--gutterNegative);</span>
}
<span class="hljs-class">.Grid-cell</span> {
  <span class="hljs-attribute">flex</span><span class="hljs-value">: <span class="hljs-number">1</span>;</span>
  <span class="hljs-attribute">margin-left</span><span class="hljs-value">: <span class="hljs-function">var</span>(--gutter);</span>
  <span class="hljs-attribute">margin-top</span><span class="hljs-value">: <span class="hljs-function">var</span>(--gutter);</span>
}
</code></pre>
<p>Even with the extra verbosity of the custom property syntax, the amount of code needed to accomplish the same thing is substantially reduced. And this only takes into account three variations. The more variations you have, the more code this will save.</p>
<p>The following demo shows a basic site layout that automatically redefines the gutter value as the viewport width changes. Check it out in a browser that supports custom properties to see it in action!</p>
<p>View the demo on CodePen:</p>
<ul>
<li><a href="http://codepen.io/philipwalton/pen/epLWNO">Editor view with code</a> →</li>
<li><a href="http://codepen.io/philipwalton/full/epLWNO/">Full page demo</a> →</li>
</ul>
<h3 id="contextual-styling">Contextual styling</h3>
<p>Contextual styling (styling an element based on where it appears in the DOM) is a contentious topic in CSS. On the one hand, it’s something most well-respected CSS developers warn against. But on the other hand, it’s something thousands of people still do every day.</p>
<p><a href="https://twitter.com/csswizardry">Harry Roberts</a> recently wrote <a href="http://csswizardry.com/2015/06/contextual-styling-ui-components-nesting-and-implementation-detail/">this post</a> with his thoughts on the matter:</p>
<blockquote>
<p>If you need to change the cosmetics of a UI component based on where it is placed, your design system is failing…Things should be designed to be ignorant; things should be designed so that we always just have “this component” and not &quot;this component when inside…</p>
</blockquote>
<p>While I do side with Harry on this (and most things), I think the fact that so many people take shortcuts in situation like this is perhaps indicative of a larger problem: that CSS is limited in its expressiveness, and most people aren’t satisfied with any of the current “best practices”.</p>
<p>The follow example shows how most people approach contextual styling in CSS, using the descendant combinator:</p>
<pre><code class="language-css"><span class="hljs-comment">/* Regular button styles. */</span>
<span class="hljs-class">.Button</span> <span class="hljs-rules">{ }</span>

<span class="hljs-comment">/* Button styles that are different when inside the header. */</span>
<span class="hljs-class">.Header</span> <span class="hljs-class">.Button</span> <span class="hljs-rules">{ }</span>
</code></pre>
<p>This approach has a lot of problems (which I explain in my article on <a href="/articles/css-architecture/#modifying-components-based-on-who-their-parents-are">CSS Architecture</a>). One way to recognize this pattern as a code smell is it violates the <a href="https://en.wikipedia.org/wiki/Open/closed_principle">open/closed principle</a> of software development; it modifies the implementation details of a closed component.</p>
<blockquote>
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
</blockquote>
<p>But custom properties change the paradigm of defining components in an interesting way. With custom properties, we can, for the first time, write components that are actually open for extension. Here’s an example:</p>
<pre><code class="language-css"><span class="hljs-class">.Button</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-function">var</span>(--Button-backgroundColor, <span class="hljs-hexcolor">#eee</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> <span class="hljs-number">1px</span> solid <span class="hljs-function">var</span>(--Button-borderColor, <span class="hljs-hexcolor">#333</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">var</span>(--Button-color, <span class="hljs-hexcolor">#333</span>)</span></span>;
  <span class="hljs-comment">/* ... */</span>
}</span>

<span class="hljs-class">.Header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--Button-backgroundColor</span>:<span class="hljs-value"> purple</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--Button-borderColor</span>:<span class="hljs-value"> transparent</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--Button-color</span>:<span class="hljs-value"> white</span></span>;
}</span>
</code></pre>
<p>The difference between this and the descendant combinator example is subtle but important.</p>
<p>When using descendant combinators we’re declaring that buttons inside the header <em>will look this way</em>, and that way is different from how the button component defines itself. Such a declaration is dictatorial (to borrow Harry’s word) and hard to undo in the case of an exception where a button in the header <em>doesn’t</em> need to look this way.</p>
<p>With custom properties, on the other hand, the button component is still ignorant of its context and completely decoupled from the header component. Its declaration simply says: <em>I’m going to style myself based on these variables, whatever they happen to be in my current situation</em>. And the header component simply says: <em>I’m going to set these property values; it’s up to my descendants to determine if and how to use them</em>.</p>
<p>The main difference is that the extension is opt-in by the button component, and it’s easily undone in the case of an exception.</p>
<p>To make that last point more clear, imagine if a <code>.Promo</code> component were added to the header, and buttons inside the <code>.Promo</code> component needed to look like normal buttons, not header buttons.</p>
<p>If you were using descendant combinators, you’d have to write a bunch of styles for the header buttons and then <em>undo</em> those styles for the promo buttons; which is messy and error prone, and easily gets out of hand as the number of combinations increases:</p>
<pre><code class="language-css"><span class="hljs-comment">/* Regular button styles. */</span>
<span class="hljs-class">.Button</span> <span class="hljs-rules">{ }</span>

<span class="hljs-comment">/* Button styles that are different when inside the header. */</span>
<span class="hljs-class">.Header</span> <span class="hljs-class">.Button</span> <span class="hljs-rules">{ }</span>

<span class="hljs-comment">/* Undo button styles in the header that are also in promo. */</span>
<span class="hljs-class">.Header</span> <span class="hljs-class">.Promo</span> <span class="hljs-class">.Button</span> <span class="hljs-rules">{ }</span>
</code></pre>
<p>With custom properties, you can simply update the button properties to be whatever you want, or reset them to return to the default styling. And regardless of the number of exceptions, the way to alter the styles is always the same.</p>
<pre><code class="language-css"><span class="hljs-class">.Promo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">--Button-backgroundColor</span>:<span class="hljs-value"> initial</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--Button-borderColor</span>:<span class="hljs-value"> initial</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--Button-color</span>:<span class="hljs-value"> initial</span></span>;
}</span>
</code></pre>
<p>The following demo illustrates contextual styling of both links and buttons in the header of a site as well as the content area.</p>
<p>View the demo on CodePen:</p>
<ul>
<li><a href="http://codepen.io/philipwalton/pen/KdxmWL">Editor view with code</a> →</li>
<li><a href="http://codepen.io/philipwalton/full/KdxmWL/">Full page demo</a> →</li>
</ul>
<h4 id="learning-from-react">Learning from React</h4>
<p>When I was first exploring the idea of contextual styling via custom properties, I was skeptical. Like I said, my inclination is to prefer context-agnostic components that define their own variations rather than adapting to arbitrary data inherited from their parent.</p>
<p>But one thing that helped sway my opinion was comparing custom properties in CSS to <code>props</code> in React components.</p>
<p>Arguably the most significant way React has changed web development is its championing of a single-directional (one-way) flow of data. In React, parent components pass data to child components via <code>props</code>, and child components define what <code>props</code> they’re willing to accept and how they’re going to use them.</p>
<p>This architectural model is almost exactly the same as inheritable custom properties in CSS.</p>
<p>Even though custom properties are a new, untested domain, I think the success of the React model gives me confidence that a complex system can be built on top of one-way property inheritance.</p>
<h2 id="minimizing-side-effects">Minimizing side effects</h2>
<p>Unlike <code>props</code> in React, CSS custom properties all inherit by default. In some cases, this could lead to components being styled in ways they may not have intended. This can be avoided though, because it’s possible to prevent custom properties from inheriting.</p>
<p>To completely prevent any properties from being inherited by a particular component you can set the <code>all</code> property to <code>initial</code>.</p>
<pre><code class="language-css"><span class="hljs-class">.MyComponent</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">all</span>:<span class="hljs-value"> initial</span></span>;
}</span>
</code></pre>
<p>If you want only white-listed custom properties to inherit, you can use a combination of <code>all</code> and setting individual, allowed properties to inherit:</p>
<pre><code class="language-css"><span class="hljs-class">.MyComponent</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">all</span>:<span class="hljs-value"> initial</span></span>;

  <span class="hljs-comment">/* Whitelists these individual custom properties */</span>
  <span class="hljs-rule"><span class="hljs-attribute">--color</span>:<span class="hljs-value"> inherit</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--font</span>:<span class="hljs-value"> inherit</span></span>;
}</span>
</code></pre>
<p>Though not part of the specification yet, the <code>--</code> property has <a href="https://github.com/w3c/webcomponents/issues/300#issuecomment-144551648">been discussed</a>, which could be used to reset only custom properties, while allowing regular inheritable properties (e.g. <code>color</code>, <code>font-family</code>) to inherit as normal.</p>
<pre><code class="language-css"><span class="hljs-class">.MyComponent</span> <span class="hljs-rules">{
  <span class="hljs-comment">/* Resets only custom properties. */</span>
  <span class="hljs-rule"><span class="hljs-attribute">--</span>:<span class="hljs-value"> initial</span></span>;

  <span class="hljs-comment">/* Whitelists these individual custom properties */</span>
  <span class="hljs-rule"><span class="hljs-attribute">--color</span>:<span class="hljs-value"> inherit</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">--font</span>:<span class="hljs-value"> inherit</span></span>;
}</span>
</code></pre>
<h3 id="managing-global-names">Managing global names</h3>
<p>If you’ve been paying attention to how I name my custom properties, you’ve probably noticed that I prefix them with the class name of the component, e.g. <code>--Button-backgroundColor</code>.</p>
<p>Like most names in CSS, custom properties are global and there’s always the possibility that they’ll conflict with names being used by other developers on your team.</p>
<p>An easy way to avoid this problem is to stick to a naming convention, like I’ve done here.</p>
<p>For more complex projects, you’d probably want to consider something like <a href="https://github.com/css-modules/css-modules">CSS Modules</a> which localifies all global names and has recently <a href="https://github.com/css-modules/postcss-modules-values/issues/6#issuecomment-155526613">expressed interest</a> in supporting custom properties.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>If you weren’t familiar with custom properties in CSS before reading this article, I hope I’ve convinced you to give them a shot. And if you were one of the people skeptical of their necessity, I hope I’ve changed your mind.</p>
<p>Custom properties bring a new set of dynamic and powerful capabilities to CSS, and I’m sure many of their biggest strengths are yet to be uncovered.</p>
<p>Custom properties fill a gap that preprocessor variables simply can’t. Despite that, preprocessor variables remain the easier-to-use and more elegant choice in many cases.</p>
<p>Because of this, I firmly believe that many sites will use a combination of both in the future. Custom properties for reactive theming and preprocessor variables for static templating.</p>
<p>I don’t think it has to be an either-or situation. And pitting them against each other as competitors does a disservice to everyone.</p>

      
  </div>

  <footer class="entry-unrelated">
    <div class="Share">
      <span class="Share-figure">
        <svg viewBox="0 0 39 32">
          <use xlink:href="#icon-twitter-bird"></use>
        </svg>
      </span>
      <p class="Share-pitch">
        If you liked this article and think others should read it, please

        

        <a data-social-network="Twitter"
           data-social-action="tweet"
           href="http://twitter.com/intent/tweet?text=Why%20I'm%20Excited%20About%20Native%20CSS%20Variables&url=http%3A%2F%2Fphilipwalton.com%2Farticles%2Fwhy-im-excited-about-native-css-variables%2F&via=philwalton">
           share it on Twitter</a>.
      </p>
    </div>
  </footer>

</article>


    